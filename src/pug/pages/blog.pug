//- blog.pug

extends ../template
include ../mixins/mixins

block content
    .wrapper
        include ../modules/fixed-menu
        header.header
            +header("img/svg/sprite.min.svg#portfolio_header", "Блог", "Статьи, которые я написал", "header_upper_case")
        main.content
            section.blog#up
                svg.left-svg(viewbox="0 0 1000 175" preserveAspectRatio="none")
                    polygon(points="0,175 1000,175 1000,0" fill="#fff")
                svg.right-svg.right-svg_position(viewbox="0 0 1000 175" preserveAspectRatio="none")
                        polygon(points="0,175 1000,175 1000,0" fill="#fff")
                aside.blog-menu
                    a(href="").push-menu                      
                    nav.blog-nav
                        ul.blog-nav__list
                            +blog-nav("Как оживить картинку в браузере?")
                            +blog-nav("Ошибка на сайте… Что делать?")
                            +blog-nav("Основы регулярных выражений в JavaScript")
                            +blog-nav("Как два браузера договариваются о голосовых и видеозвонках.")
                .blog-info
                    +blog-info("Как оживить картинку в браузере?", "21 декабря 2017", "Каждый, кто сталкивался с трехмерной графикой, рано или поздно открывал документацию на методы отрисовки, которые предполагают несколько проходов рендерера. Такие методы позволяют дополнить картинку красивыми эффектами, вроде свечения ярких пятен (Glow), Ambient occlusion, эффекта глубины резкости. И «взрослый» OpenGL, и мой любимый WebGL предлагают богатую функциональность для отрисовки результатов в промежуточные текстуры. Однако управление этой функциональностью — довольно сложный процесс, в котором очень легко получить ошибку на любом из этапов, начиная от создания текстур нужного разрешения до именования юниформ и передачи их в соответствующий шейдер.")
                    +blog-info("Ошибка на сайте… Что делать?", "20 декабря 2017", "Когда код попадает в продакшн, программист выпускает во внешний мир, вместе с полезным функционалом, ещё и ошибки. Вполне возможно, что они, например, на некоем сайте, будут иногда приводить к мелким сбоям, которые спишут на самые разные причины, так и не докопавшись до сути. Знающему своё дело разработчику хорошо бы предусмотреть какой-то механизм, благодаря которому он сможет встретиться со своими ошибками, выслушать их рассказ о тех приключениях, которые им пришлось пережить, и, в результате, их исправить.")
                    +blog-info("Основы регулярных выражений в JavaScript", "17 декабря 2017", "Если вы иногда поглядываете на регулярные выражения, но всё никак не решаетесь их освоить, думая, что всё это невероятно сложно — знайте — вы не одиноки. Для любого, кто не понимает, что такое регулярные выражения, или не разбирается в том, как они работают, они выглядят как совершенная бессмыслица. Но, на самом деле, регулярные выражения — это мощный инструмент, который может помочь вам сэкономить уйму времени.")
                    +blog-info("Как два браузера договариваются о голосовых и видеозвонках.", "15 декабря 2017", "Спойлер: никак. За них это делает разработчик. Когда много лет назад начали убивать Flash, пострадали не только браузерные игры. Flash традиционно была сильна в голосовых и видеозвонках: прямой доступ к микрофону, камере, динамикам, возможность работать с UDP-пакетами. В HTML5 заменой стала технология WebRTC. Та самая, которая несколько месяцев назад наконец-то приземлилась в Safari и Edge. Теперь можно звонить с веб-страницы, открытой на iPhone, на другую веб-страницу, например, открытую в Firefox Quantum на линуксе. Одна из «фишек» WebRTC, которой не было у Flash — это возможность P2P-соединений между браузерами. Но чтобы peer-to-peer работал, программисту придется помучиться.")
        footer.footer
            +footer
    script(src='js/main.min.js')
